//swiftc -O -framework SwiftUI -framework AppKit -framework UniformTypeIdentifiers Gemini.swift -o Gemini
import SwiftUI
import AppKit
import Observation
import UniformTypeIdentifiers

// MARK: - 1. 模型层 & 数据结构

struct ChatPart: Codable, Equatable {
    var text: String?
    var inlineData: InlineData?
    
    var displayString: String { text ?? "" }
}

struct InlineData: Codable, Equatable {
    let mimeType: String
    let data: String // Base64 Encoded
    
    enum CodingKeys: String, CodingKey {
        case mimeType = "mime_type"
        case data
    }
}

struct ChatMessage: Codable, Identifiable, Equatable {
    var id = UUID()
    let role: String
    let parts: [ChatPart]
    
    enum CodingKeys: String, CodingKey { case role, parts }
    
    static func == (lhs: ChatMessage, rhs: ChatMessage) -> Bool {
        return lhs.id == rhs.id && lhs.parts == rhs.parts
    }
}

struct GeminiResponse: Codable {
    struct Candidate: Codable {
        struct Content: Codable { let parts: [ChatPart] }
        let content: Content
    }
    let candidates: [Candidate]?
}

struct PendingAttachment: Equatable {
    let url: URL
    let data: Data
    let mimeType: String
}

@Observable
class ChatViewModel {
    var chatHistory: [ChatMessage] = []
    var isSending = false
    var apiKey: String = ""
    var pendingAttachment: PendingAttachment? = nil
    var errorMessage: String? = nil
    
    private let historyPath = "/tmp/gemini_history_swift.json"

    func loadHistory() {
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: historyPath)),
              let decoded = try? JSONDecoder().decode([ChatMessage].self, from: data) else { return }
        self.chatHistory = decoded
    }
    
    func saveHistory() {
        if let data = try? JSONEncoder().encode(chatHistory) {
            try? data.write(to: URL(fileURLWithPath: historyPath))
        }
    }
    
    func clearHistory() {
        chatHistory.removeAll()
        try? FileManager.default.removeItem(atPath: historyPath)
    }
    
    func selectFile() {
        let panel = NSOpenPanel()
        panel.allowsMultipleSelection = false
        panel.canChooseDirectories = false
        panel.canChooseFiles = true
        panel.allowedContentTypes = [.image, .pdf]
        
        panel.begin { [weak self] response in
            guard response == .OK, let url = panel.url else { return }
            self?.processAttachment(url: url)
        }
    }
    
    // 修复：添加 Task 包裹以支持异步操作和后台读取
    private func processAttachment(url: URL) {
        Task {
            do {
                // 在后台线程读取文件，不阻塞 UI
                let data = try Data(contentsOf: url)
                
                if data.count > 4 * 1024 * 1024 {
                    await MainActor.run {
                        self.errorMessage = "File too large (Max 4MB recommended)"
                    }
                    return
                }
                
                let mimeType = UTType(filenameExtension: url.pathExtension)?.preferredMIMEType ?? "application/octet-stream"
                
                // 回到主线程更新 UI 状态
                await MainActor.run {
                    self.pendingAttachment = PendingAttachment(url: url, data: data, mimeType: mimeType)
                }
            } catch {
                await MainActor.run {
                    self.errorMessage = "Failed to read file: \(error.localizedDescription)"
                }
            }
        }
    }
    
    func removeAttachment() {
        pendingAttachment = nil
    }
    
    func sendToGemini(text: String) async {
        guard !text.isEmpty || pendingAttachment != nil else { return }
        
        let currentAttachment = pendingAttachment
        
        await MainActor.run {
            var parts: [ChatPart] = []
            
            if let att = currentAttachment {
                let base64String = att.data.base64EncodedString()
                parts.append(ChatPart(text: nil, inlineData: InlineData(mimeType: att.mimeType, data: base64String)))
            }
            
            if !text.isEmpty {
                parts.append(ChatPart(text: text, inlineData: nil))
            }
            
            chatHistory.append(ChatMessage(role: "user", parts: parts))
            isSending = true
            pendingAttachment = nil
        }
        
        // 使用 gemini-1.5-flash 以获得较好的多模态支持
        let endpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=\(apiKey)"
        
        guard let url = URL(string: endpoint) else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let apiHistory = chatHistory.map { msg in
            return [
                "role": msg.role,
                "parts": msg.parts.map { part -> [String: Any] in
                    var dict: [String: Any] = [:]
                    if let t = part.text { dict["text"] = t }
                    if let d = part.inlineData {
                        dict["inline_data"] = ["mime_type": d.mimeType, "data": d.data]
                    }
                    return dict
                }
            ]
        }
        
        request.httpBody = try? JSONSerialization.data(withJSONObject: ["contents": apiHistory])
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            
            if let response = try? JSONDecoder().decode(GeminiResponse.self, from: data),
               let candidates = response.candidates,
               let firstPart = candidates.first?.content.parts.first {
                
                await MainActor.run {
                    let responseText = firstPart.text ?? "No text response"
                    chatHistory.append(ChatMessage(role: "model", parts: [ChatPart(text: responseText, inlineData: nil)]))
                    saveHistory()
                }
            } else {
                if let errorStr = String(data: data, encoding: .utf8) {
                    print("API Error: \(errorStr)")
                    await MainActor.run { errorMessage = "API Error. Check console." }
                }
            }
        } catch {
            print("Network Error: \(error)")
            await MainActor.run { errorMessage = "Network Error: \(error.localizedDescription)" }
        }
        await MainActor.run { isSending = false }
    }
}

// MARK: - 2. UI 层

struct MessageRow: View, Equatable {
    let msg: ChatMessage
    
    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(msg.role == "user" ? "You" : "Gemini")
                .font(.system(size: 12, weight: .semibold))
                .foregroundColor(.secondary)
            
            ForEach(msg.parts.indices, id: \.self) { index in
                let part = msg.parts[index]
                
                if let text = part.text {
                    Text(text)
                        .font(.system(size: 15))
                        .lineSpacing(4)
                        .fixedSize(horizontal: false, vertical: true)
                        .foregroundColor(msg.role == "user" ? .primary : Color(nsColor: .darkGray))
                        .textSelection(.enabled)
                }
                
                if let inline = part.inlineData,
                   let data = Data(base64Encoded: inline.data),
                   let nsImage = NSImage(data: data) {
                    Image(nsImage: nsImage)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(maxWidth: 300, maxHeight: 300)
                        .cornerRadius(8)
                        .overlay(RoundedRectangle(cornerRadius: 8).stroke(Color.gray.opacity(0.2), lineWidth: 1))
                }
            }
        }
        .padding(.vertical, 4)
    }
    
    static func == (lhs: MessageRow, rhs: MessageRow) -> Bool {
        return lhs.msg == rhs.msg
    }
}

struct AttachmentPreview: View {
    let attachment: PendingAttachment
    var onRemove: () -> Void
    
    var body: some View {
        HStack(spacing: 8) {
            Image(systemName: "doc.fill")
                .foregroundColor(.blue)
            Text(attachment.url.lastPathComponent)
                .font(.caption)
                .lineLimit(1)
                .truncationMode(.middle)
            
            Button(action: onRemove) {
                Image(systemName: "xmark.circle.fill")
                    .foregroundColor(.gray)
            }
            .buttonStyle(.plain)
        }
        .padding(6)
        .background(Color.blue.opacity(0.1))
        .cornerRadius(6)
        .overlay(
            RoundedRectangle(cornerRadius: 6)
                .stroke(Color.blue.opacity(0.3), lineWidth: 1)
        )
    }
}

struct ContentView: View {
    @Bindable var viewModel: ChatViewModel
    @State private var inputText = ""
    
    let paperColor = Color(red: 0.98, green: 0.976, blue: 0.965)
    let inputAreaColor = Color(red: 0.95, green: 0.95, blue: 0.95)

    var body: some View {
        VStack(spacing: 0) {
            HStack {
                Spacer()
                Button(action: { viewModel.clearHistory() }) {
                    Image(systemName: "trash")
                        .foregroundColor(.secondary)
                }
                .buttonStyle(.plain)
                .help("Clear History")
                .padding(.trailing, 20)
                .padding(.top, 10)
            }
            
            ScrollViewReader { proxy in
                ScrollView {
                    VStack(alignment: .leading, spacing: 20) {
                        ForEach(viewModel.chatHistory) { msg in
                            MessageRow(msg: msg)
                                .id(msg.id)
                        }
                    }
                    .padding(24)
                }
                .focusable()
                .onChange(of: viewModel.chatHistory.count) {
                    if let lastId = viewModel.chatHistory.last?.id {
                        proxy.scrollTo(lastId, anchor: .bottom)
                    }
                }
            }
            
            VStack(spacing: 0) {
                Divider()
                
                VStack(alignment: .leading, spacing: 8) {
                    if let attachment = viewModel.pendingAttachment {
                        AttachmentPreview(attachment: attachment) {
                            viewModel.removeAttachment()
                        }
                        .padding(.horizontal, 12)
                        .padding(.top, 8)
                        .transition(.opacity.combined(with: .move(edge: .bottom)))
                    }
                    
                    HStack(spacing: 10) {
                        Button(action: { viewModel.selectFile() }) {
                            Image(systemName: "paperclip")
                                .font(.system(size: 18))
                                .foregroundColor(.secondary)
                        }
                        .buttonStyle(.plain)
                        .help("Attach Image or PDF")
                        
                        TextField("Ask Gemini...", text: $inputText)
                            .textFieldStyle(.plain)
                            .padding(8)
                            .background(Color.white)
                            .cornerRadius(6)
                            .overlay(
                                RoundedRectangle(cornerRadius: 6)
                                    .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                            )
                            .onSubmit { sendMessage() }
                            .disabled(viewModel.isSending)
                        
                        Button(action: sendMessage) {
                            if viewModel.isSending {
                                ProgressView().controlSize(.small).scaleEffect(0.8)
                            } else {
                                Image(systemName: "arrow.up.circle.fill")
                                    .font(.system(size: 24))
                                    .foregroundColor(inputText.isEmpty && viewModel.pendingAttachment == nil ? .gray : .blue)
                            }
                        }
                        .buttonStyle(.plain)
                        .disabled(inputText.isEmpty && viewModel.pendingAttachment == nil)
                    }
                    .padding(12)
                }
                .background(inputAreaColor)
            }
        }
        .background(paperColor)
        .alert("Error", isPresented: Binding(get: { viewModel.errorMessage != nil }, set: { _ in viewModel.errorMessage = nil })) {
            Button("OK", role: .cancel) { viewModel.errorMessage = nil }
        } message: {
            Text(viewModel.errorMessage ?? "")
        }
    }
    
    func sendMessage() {
        let text = inputText
        guard !text.isEmpty || viewModel.pendingAttachment != nil else { return }
        inputText = ""
        Task { await viewModel.sendToGemini(text: text) }
    }
}

// MARK: - 3. 应用入口

class AppDelegate: NSObject, NSApplicationDelegate {
    var window: NSWindow!
    var viewModel = ChatViewModel()

    func applicationDidFinishLaunching(_ notification: Notification) {
        setupMenu()
        if CommandLine.arguments.count > 1 { viewModel.apiKey = CommandLine.arguments[1] }
        viewModel.loadHistory()

        window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 700, height: 600),
            styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
            backing: .buffered, defer: false)
        window.center()
        window.title = "Gemini Reader"
        window.isOpaque = true
        window.titlebarAppearsTransparent = true
        
        window.contentView = NSHostingView(rootView: ContentView(viewModel: viewModel))
        window.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }
    
    func setupMenu() {
        let mainMenu = NSMenu()
        let appMenuItem = NSMenuItem()
        mainMenu.addItem(appMenuItem)
        let appMenu = NSMenu()
        appMenuItem.submenu = appMenu
        appMenu.addItem(withTitle: "Quit", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        
        let editMenuItem = NSMenuItem()
        mainMenu.addItem(editMenuItem)
        let editMenu = NSMenu(title: "Edit")
        editMenuItem.submenu = editMenu
        editMenu.addItem(withTitle: "Cut", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        editMenu.addItem(withTitle: "Copy", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        editMenu.addItem(withTitle: "Paste", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        editMenu.addItem(withTitle: "Select All", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
        
        NSApp.mainMenu = mainMenu
    }
    
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool { return true }
}

let app = NSApplication.shared
let delegate = AppDelegate()
app.delegate = delegate
app.setActivationPolicy(.regular)
app.run()
