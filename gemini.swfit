/*
 ===========================================================================
 Gemini macOS Client (Swift Version)
 Eye-Care Light Theme & Paper-like Mode
 
 [功能特点]
 1. 启动即全屏：沉浸式阅读体验
 2. 护眼模式：暖白/羊皮纸背景，低对比度文字
 3. TextKit 2：高性能文本渲染
 4. 历史记录：自动保存聊天记录到 /tmp
 5. 现代并发：使用 Swift Concurrency (async/await)
 
 [编译命令]
 swiftc Gemini.swift -o Gemini
 
 [运行命令]
 ./Gemini "你的_API_KEY"
 ===========================================================================
 */

import Cocoa
import UniformTypeIdentifiers
import Foundation

// ==========================================
// 1. 全局配置与常量
// ==========================================

struct AppConfig {
    static var apiKey: String = "YOUR_API_KEY_HERE"
    static let historyFilePath = "/tmp/gemini_chat_history_swift.json"
    static let modelEndpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key="
    
    struct Fonts {
        static let text = NSFont.systemFont(ofSize: 16.0)
        static let header = NSFont.boldSystemFont(ofSize: 17.0)
        static let lineHeightMult: CGFloat = 1.25
    }
    
    struct Colors {
        // 背景：暖白/羊皮纸色 (Hex: #FAF9F6)
        static let paperBackground = NSColor(srgbRed: 0.98, green: 0.976, blue: 0.965, alpha: 1.0)
        // 用户：深灰
        static let user = NSColor(srgbRed: 0.20, green: 0.20, blue: 0.20, alpha: 1.0)
        // 模型：深蓝灰
        static let model = NSColor(srgbRed: 0.17, green: 0.24, blue: 0.31, alpha: 1.0)
        // 思考过程
        static let thought = NSColor(srgbRed: 0.50, green: 0.55, blue: 0.55, alpha: 1.0)
        // 系统/错误
        static let system = NSColor(srgbRed: 0.60, green: 0.60, blue: 0.60, alpha: 1.0)
        static let error = NSColor(srgbRed: 0.75, green: 0.22, blue: 0.17, alpha: 1.0)
    }
}

// ==========================================
// 2. 数据模型 (Codable)
// ==========================================

struct ChatPart: Codable {
    let text: String?
    let thought: String? // Gemini 2.0 Thinking logic placeholder
}

struct ChatMessage: Codable {
    let role: String
    let parts: [ChatPart]
}

struct APIRequest: Codable {
    let contents: [ChatMessage]
}

struct APIResponse: Codable {
    struct Candidate: Codable {
        struct Content: Codable {
            let parts: [ChatPart]
        }
        let content: Content
    }
    struct APIError: Codable {
        let message: String
    }
    
    let candidates: [Candidate]?
    let error: APIError?
}

// ==========================================
// 3. ChatWindowController (核心逻辑)
// ==========================================

class ChatWindowController: NSWindowController, NSWindowDelegate, NSTextFieldDelegate {
    
    // TextKit 2 Components
    private var textView: NSTextView!
    private var textContentStorage: NSTextContentStorage!
    private var textLayoutManager: NSTextLayoutManager!
    private var textContainer: NSTextContainer!
    
    // UI Components
    private var inputField: NSTextField!
    private var sendButton: NSButton!
    private var effectView: NSVisualEffectView!
    
    // Data
    private var chatHistory: [ChatMessage] = []
    
    init() {
        let frame = NSRect(x: 0, y: 0, width: 1000, height: 800)
        let style: NSWindow.StyleMask = [.titled, .closable, .resizable, .miniaturizable, .fullSizeContentView]
        
        let window = NSWindow(contentRect: frame, styleMask: style, backing: .buffered, defer: false)
        window.title = "Gemini Reader (Swift)"
        window.minSize = NSSize(width: 600, height: 500)
        window.collectionBehavior = .fullScreenPrimary
        
        // 透明化基础设置
        window.isOpaque = false
        window.backgroundColor = .clear
        window.titlebarAppearsTransparent = true
        window.appearance = NSAppearance(named: .aqua) // 强制浅色以配合纸张主题
        
        super.init(window: window)
        
        setupUI()
        loadHistoryFromDisk()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupUI() {
        guard let window = self.window, let contentView = window.contentView else { return }
        let bounds = contentView.bounds
        
        // 1. 背景层：毛玻璃 + 暖色滤镜
        effectView = NSVisualEffectView(frame: bounds)
        effectView.autoresizingMask = [.width, .height]
        effectView.material = .underPageBackground
        effectView.blendingMode = .behindWindow
        effectView.state = .active
        window.contentView = effectView
        
        let tintView = NSView(frame: bounds)
        tintView.autoresizingMask = [.width, .height]
        tintView.wantsLayer = true
        // 0.85 的透明度：透出一点点背景模糊
        tintView.layer?.backgroundColor = AppConfig.Colors.paperBackground.withAlphaComponent(0.85).cgColor
        effectView.addSubview(tintView)
        
        // 2. 文本区域 (TextKit 2)
        let scrollView = NSScrollView(frame: NSRect(x: 30, y: 80, width: bounds.width - 60, height: bounds.height - 110))
        scrollView.hasVerticalScroller = true
        scrollView.autoresizingMask = [.width, .height]
        scrollView.drawsBackground = false // 透明
        
        textContentStorage = NSTextContentStorage()
        textLayoutManager = NSTextLayoutManager()
        textContentStorage.addTextLayoutManager(textLayoutManager)
        
        textContainer = NSTextContainer(size: NSSize(width: scrollView.contentSize.width, height: CGFloat.greatestFiniteMagnitude))
        textContainer.widthTracksTextView = true
        textContainer.heightTracksTextView = false
        textLayoutManager.textContainer = textContainer
        
        textView = NSTextView(frame: scrollView.bounds, textContainer: textContainer)
        textView.minSize = NSSize(width: 0, height: scrollView.contentSize.height)
        textView.maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = false
        textView.autoresizingMask = .width
        textView.isEditable = false
        textView.isSelectable = true
        textView.textContainerInset = NSSize(width: 10, height: 20)
        textView.font = AppConfig.Fonts.text
        textView.drawsBackground = false // 关键：透明
        
        scrollView.documentView = textView
        effectView.addSubview(scrollView)
        
        // 3. 底部输入区
        let bottomY: CGFloat = 30
        let buttonHeight: CGFloat = 32
        
        inputField = NSTextField(frame: NSRect(x: 30, y: bottomY, width: 600, height: buttonHeight))
        inputField.placeholderString = "Ask Gemini..."
        inputField.font = NSFont.systemFont(ofSize: 14)
        inputField.bezelStyle = .roundedBezel
        inputField.delegate = self
        inputField.target = self
        inputField.action = #selector(onEnterPressed)
        inputField.autoresizingMask = [.width, .maxYMargin] // 随宽度调整
        inputField.wantsLayer = true
        inputField.layer?.backgroundColor = NSColor(white: 1.0, alpha: 0.6).cgColor
        effectView.addSubview(inputField)
        
        let btnX: CGFloat = 640
        
        sendButton = NSButton(title: "Send", target: self, action: #selector(onSendClicked))
        sendButton.bezelStyle = .rounded
        sendButton.frame = NSRect(x: btnX, y: bottomY, width: 70, height: buttonHeight)
        sendButton.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(sendButton)
        
        let uploadBtn = NSButton(title: "Upload", target: self, action: #selector(onUploadClicked))
        uploadBtn.bezelStyle = .rounded
        uploadBtn.frame = NSRect(x: btnX + 80, y: bottomY, width: 70, height: buttonHeight)
        uploadBtn.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(uploadBtn)
        
        let clearBtn = NSButton(title: "Clear", target: self, action: #selector(onClearClicked))
        clearBtn.bezelStyle = .rounded
        clearBtn.frame = NSRect(x: btnX + 160, y: bottomY, width: 70, height: buttonHeight)
        clearBtn.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(clearBtn)
    }
    
    // ==========================================
    // 逻辑处理
    // ==========================================
    
    @objc private func onEnterPressed() {
        onSendClicked()
    }
    
    @objc private func onSendClicked() {
        let input = inputField.stringValue
        guard !input.isEmpty else { return }
        
        if input == "/clear" {
            onClearClicked()
            inputField.stringValue = ""
            return
        }
        
        processUserMessage(input)
        inputField.stringValue = ""
    }
    
    @objc private func onUploadClicked() {
        let panel = NSOpenPanel()
        panel.canChooseFiles = true
        panel.canChooseDirectories = false
        panel.allowsMultipleSelection = false
        panel.allowedContentTypes = [.plainText, .sourceCode, .json, .xml, .html]
        
        panel.beginSheetModal(for: self.window!) { response in
            if response == .OK, let url = panel.urls.first {
                do {
                    let content = try String(contentsOf: url, encoding: .utf8)
                    let msg = "[File Upload: \(url.lastPathComponent)]\n\n\(content)"
                    self.processUserMessage(msg)
                } catch {
                    self.appendLog(header: "[Error]", content: error.localizedDescription, color: AppConfig.Colors.error)
                }
            }
        }
    }
    
    @objc private func onClearClicked() {
        chatHistory.removeAll()
        saveHistoryToDisk()
        
        // 清空 UI
        textContentStorage.performEditingTransaction {
            textContentStorage.textStorage?.deleteCharacters(in: NSRange(location: 0, length: textContentStorage.textStorage!.length))
        }
        appendLog(header: "[System]", content: "History cleared.", color: AppConfig.Colors.system)
    }
    
    private func processUserMessage(_ text: String) {
        appendLog(header: "You", content: text, color: AppConfig.Colors.user)
        
        let userMsg = ChatMessage(role: "user", parts: [ChatPart(text: text, thought: nil)])
        chatHistory.append(userMsg)
        saveHistoryToDisk()
        
        callGeminiAPI()
    }
    
    // ==========================================
    // API 网络请求 (Swift Concurrency)
    // ==========================================
    
    private func callGeminiAPI() {
        setUIEnabled(false)
        
        Task {
            do {
                let response = try await fetchGeminiResponse(history: chatHistory)
                
                await MainActor.run {
                    self.handleAPIResponse(response)
                    self.setUIEnabled(true)
                }
            } catch {
                await MainActor.run {
                    self.appendLog(header: "[Network Error]", content: error.localizedDescription, color: AppConfig.Colors.error)
                    self.setUIEnabled(true)
                }
            }
        }
    }
    
    private func fetchGeminiResponse(history: [ChatMessage]) async throws -> APIResponse {
        guard let url = URL(string: AppConfig.modelEndpoint + AppConfig.apiKey) else {
            throw URLError(.badURL)
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let payload = APIRequest(contents: history)
        request.httpBody = try JSONEncoder().encode(payload)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        return try JSONDecoder().decode(APIResponse.self, from: data)
    }
    
    private func handleAPIResponse(_ response: APIResponse) {
        if let error = response.error {
            appendLog(header: "[API Error]", content: error.message, color: AppConfig.Colors.error)
            return
        }
        
        guard let candidate = response.candidates?.first,
              let parts = Optional(candidate.content.parts), !parts.isEmpty else {
            return
        }
        
        var fullText = ""
        
        for part in parts {
            if let thought = part.thought {
                appendLog(header: "Thinking", content: thought, color: AppConfig.Colors.thought)
            }
            if let text = part.text {
                fullText += text
            }
        }
        
        if !fullText.isEmpty {
            appendLog(header: "Gemini", content: fullText, color: AppConfig.Colors.model)
            
            let modelMsg = ChatMessage(role: "model", parts: [ChatPart(text: fullText, thought: nil)])
            chatHistory.append(modelMsg)
            saveHistoryToDisk()
        }
    }
    
    // ==========================================
    // 辅助方法：UI与存储
    // ==========================================
    
    private func appendLog(header: String, content: String, color: NSColor) {
        let paraStyle = NSMutableParagraphStyle()
        paraStyle.lineBreakMode = .byWordWrapping
        paraStyle.lineHeightMultiple = AppConfig.Fonts.lineHeightMult
        
        let mas = NSMutableAttributedString()
        
        // 标题
        let headerAttrs: [NSAttributedString.Key: Any] = [
            .font: AppConfig.Fonts.header,
            .foregroundColor: color,
            .paragraphStyle: paraStyle
        ]
        mas.append(NSAttributedString(string: "\(header)\n", attributes: headerAttrs))
        
        // 内容
        let contentAttrs: [NSAttributedString.Key: Any] = [
            .font: AppConfig.Fonts.text,
            .foregroundColor: color,
            .paragraphStyle: paraStyle
        ]
        mas.append(NSAttributedString(string: "\(content)\n", attributes: contentAttrs))
        
        // 空行
        mas.append(NSAttributedString(string: "\n", attributes: [.paragraphStyle: paraStyle]))
        
        textContentStorage.performEditingTransaction {
            textContentStorage.textStorage?.append(mas)
        }
        
        scrollToBottom()
    }
    
    private func scrollToBottom() {
        // 确保布局更新
        textLayoutManager.ensureLayout(for: textContentStorage.documentRange)
        
        DispatchQueue.main.async {
            guard let string = self.textView.textStorage?.string, !string.isEmpty else { return }
            self.textView.scrollRangeToVisible(NSRange(location: string.count, length: 0))
        }
    }
    
    private func setUIEnabled(_ enabled: Bool) {
        inputField.isEnabled = enabled
        sendButton.isEnabled = enabled
    }
    
    // ==========================================
    // 历史记录
    // ==========================================
    
    private func loadHistoryFromDisk() {
        let fileURL = URL(fileURLWithPath: AppConfig.historyFilePath)
        guard FileManager.default.fileExists(atPath: fileURL.path) else { return }
        
        do {
            let data = try Data(contentsOf: fileURL)
            let loadedHistory = try JSONDecoder().decode([ChatMessage].self, from: data)
            self.chatHistory = loadedHistory
            
            appendLog(header: "[System]", content: "Loaded \(loadedHistory.count) messages", color: AppConfig.Colors.system)
            
            for msg in loadedHistory {
                let roleDisplay = msg.role == "user" ? "You" : "Gemini"
                let color = msg.role == "user" ? AppConfig.Colors.user : AppConfig.Colors.model
                let text = msg.parts.first?.text ?? ""
                appendLog(header: roleDisplay, content: text, color: color)
            }
            scrollToBottom()
        } catch {
            print("Failed to load history: \(error)")
        }
    }
    
    private func saveHistoryToDisk() {
        let fileURL = URL(fileURLWithPath: AppConfig.historyFilePath)
        do {
            let data = try JSONEncoder().encode(chatHistory)
            try data.write(to: fileURL)
        } catch {
            print("Failed to save history: \(error)")
        }
    }
}

// ==========================================
// 4. App Entry (程序入口)
// ==========================================

class AppDelegate: NSObject, NSApplicationDelegate {
    var windowController: ChatWindowController!
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        setupMainMenu()
        
        windowController = ChatWindowController()
        windowController.showWindow(self)
        
        NSApp.activate(ignoringOtherApps: true)
        windowController.window?.makeKeyAndOrderFront(nil)
        
        // 触发全屏
        windowController.window?.toggleFullScreen(nil)
    }
    
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return true
    }
    
    private func setupMainMenu() {
        let mainMenu = NSMenu()
        NSApp.mainMenu = mainMenu
        
        // App Menu
        let appMenuItem = NSMenuItem()
        mainMenu.addItem(appMenuItem)
        let appMenu = NSMenu()
        appMenuItem.submenu = appMenu
        appMenu.addItem(withTitle: "Quit Gemini", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        
        // Edit Menu (Standard Copy/Paste support)
        let editMenuItem = NSMenuItem()
        mainMenu.addItem(editMenuItem)
        let editMenu = NSMenu(title: "Edit")
        editMenuItem.submenu = editMenu
        editMenu.addItem(withTitle: "Undo", action: Selector(("undo:")), keyEquivalent: "z")
        editMenu.addItem(withTitle: "Redo", action: Selector(("redo:")), keyEquivalent: "Z")
        editMenu.addItem(.separator())
        editMenu.addItem(withTitle: "Cut", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        editMenu.addItem(withTitle: "Copy", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        editMenu.addItem(withTitle: "Paste", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        editMenu.addItem(withTitle: "Select All", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
    }
}

// Main Entry
@main
struct GeminiApp {
    static func main() {
        // 读取命令行参数
        if CommandLine.arguments.count > 1 {
            AppConfig.apiKey = CommandLine.arguments[1]
        }
        
        let app = NSApplication.shared
        app.setActivationPolicy(.regular)
        let delegate = AppDelegate()
        app.delegate = delegate
        app.run()
    }
}
