//swiftc -parse-as-library Gemini.swift -o Gemini
/*
 ===========================================================================
 Gemini macOS Client (Swift Version) - High Performance Edition
 
 [优化点]
 1. 异步 I/O：文件保存移至后台线程，不再阻塞 UI
 2. GPU 加速：开启 Layer Backing，降低滚动时的 CPU 消耗
 3. 懒加载布局：移除强制全局重排版，利用 TextKit 2 惰性计算
 4. 内存保护：限制历史记录上下文长度
 ===========================================================================
 */

import Cocoa
import UniformTypeIdentifiers
import Foundation

// ==========================================
// 1. 全局配置与常量
// ==========================================

struct AppConfig {
    static var apiKey: String = "YOUR_API_KEY_HERE"
    static let historyFilePath = "/tmp/gemini_chat_history_swift.json"
    // 使用 flash 模型以获得更快速度
    static let modelEndpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key="
    
    // [优化] 最大上下文保留条数，防止 JSON 膨胀导致 I/O 缓慢
    static let maxHistoryMessages = 50 
    
    struct Fonts {
        static let text = NSFont.systemFont(ofSize: 16.0)
        static let header = NSFont.boldSystemFont(ofSize: 17.0)
        static let lineHeightMult: CGFloat = 1.25
    }
    
    struct Colors {
        static let paperBackground = NSColor(srgbRed: 0.98, green: 0.976, blue: 0.965, alpha: 1.0)
        static let user = NSColor(srgbRed: 0.20, green: 0.20, blue: 0.20, alpha: 1.0)
        static let model = NSColor(srgbRed: 0.17, green: 0.24, blue: 0.31, alpha: 1.0)
        static let thought = NSColor(srgbRed: 0.50, green: 0.55, blue: 0.55, alpha: 1.0)
        static let system = NSColor(srgbRed: 0.60, green: 0.60, blue: 0.60, alpha: 1.0)
        static let error = NSColor(srgbRed: 0.75, green: 0.22, blue: 0.17, alpha: 1.0)
    }
}

// ==========================================
// 2. 数据模型
// ==========================================

struct ChatPart: Codable {
    let text: String?
    let thought: String?
}

struct ChatMessage: Codable {
    let role: String
    let parts: [ChatPart]
}

struct APIRequest: Codable {
    let contents: [ChatMessage]
}

struct APIResponse: Codable {
    struct Candidate: Codable {
        struct Content: Codable {
            let parts: [ChatPart]?
        }
        let content: Content
    }
    struct APIError: Codable {
        let message: String
    }
    
    let candidates: [Candidate]?
    let error: APIError?
}

// ==========================================
// 3. ChatWindowController (核心逻辑)
// ==========================================

class ChatWindowController: NSWindowController, NSWindowDelegate, NSTextFieldDelegate {
    
    private var textView: NSTextView!
    private var textContentStorage: NSTextContentStorage!
    private var textLayoutManager: NSTextLayoutManager!
    private var textContainer: NSTextContainer!
    
    private var inputField: NSTextField!
    private var sendButton: NSButton!
    private var effectView: NSVisualEffectView!
    
    private var chatHistory: [ChatMessage] = []
    
    // [优化] 用于后台保存文件的串行队列，防止写入冲突
    private let ioQueue = DispatchQueue(label: "com.gemini.ioQueue", qos: .background)
    
    init() {
        let frame = NSRect(x: 0, y: 0, width: 1000, height: 800)
        let style: NSWindow.StyleMask = [.titled, .closable, .resizable, .miniaturizable, .fullSizeContentView]
        
        let window = NSWindow(contentRect: frame, styleMask: style, backing: .buffered, defer: false)
        window.title = "Gemini Reader (Optimized)"
        window.minSize = NSSize(width: 600, height: 500)
        window.collectionBehavior = .fullScreenPrimary
        
        window.isOpaque = false
        window.backgroundColor = .clear
        window.titlebarAppearsTransparent = true
        window.appearance = NSAppearance(named: .aqua)
        
        super.init(window: window)
        
        setupUI()
        loadHistoryFromDisk()
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    private func setupUI() {
        guard let window = self.window, let contentView = window.contentView else { return }
        let bounds = contentView.bounds
        
        // 1. 背景层
        effectView = NSVisualEffectView(frame: bounds)
        effectView.autoresizingMask = [.width, .height]
        effectView.material = .underPageBackground
        effectView.blendingMode = .behindWindow
        effectView.state = .active
        // [优化] 开启 Layer，减少重绘
        effectView.wantsLayer = true
        window.contentView = effectView
        
        let tintView = NSView(frame: bounds)
        tintView.autoresizingMask = [.width, .height]
        tintView.wantsLayer = true
        tintView.layer?.backgroundColor = AppConfig.Colors.paperBackground.withAlphaComponent(0.85).cgColor
        effectView.addSubview(tintView)
        
        // 2. 文本区域
        let scrollView = NSScrollView(frame: NSRect(x: 30, y: 80, width: bounds.width - 60, height: bounds.height - 110))
        scrollView.hasVerticalScroller = true
        scrollView.autoresizingMask = [.width, .height]
        scrollView.drawsBackground = false
        // [优化] 关键：开启 ScrollView 的 Layer Backing，大幅降低滚动 CPU 占用
        scrollView.wantsLayer = true
        
        textContentStorage = NSTextContentStorage()
        textLayoutManager = NSTextLayoutManager()
        textContentStorage.addTextLayoutManager(textLayoutManager)
        
        textContainer = NSTextContainer(size: NSSize(width: scrollView.contentSize.width, height: CGFloat.greatestFiniteMagnitude))
        textContainer.widthTracksTextView = true
        textContainer.heightTracksTextView = false
        textLayoutManager.textContainer = textContainer
        
        textView = NSTextView(frame: scrollView.bounds, textContainer: textContainer)
        textView.minSize = NSSize(width: 0, height: scrollView.contentSize.height)
        textView.maxSize = NSSize(width: CGFloat.greatestFiniteMagnitude, height: CGFloat.greatestFiniteMagnitude)
        textView.isVerticallyResizable = true
        textView.isHorizontallyResizable = false
        textView.autoresizingMask = .width
        textView.isEditable = false
        textView.isSelectable = true
        textView.textContainerInset = NSSize(width: 10, height: 20)
        textView.font = AppConfig.Fonts.text
        textView.drawsBackground = false
        // [优化] 开启 TextView 的 Layer Backing
        textView.wantsLayer = true
        
        scrollView.documentView = textView
        effectView.addSubview(scrollView)
        
        // 3. 底部 UI
        let bottomY: CGFloat = 30
        let buttonHeight: CGFloat = 32
        
        inputField = NSTextField(frame: NSRect(x: 30, y: bottomY, width: 600, height: buttonHeight))
        inputField.placeholderString = "Ask Gemini..."
        inputField.font = NSFont.systemFont(ofSize: 14)
        inputField.bezelStyle = .roundedBezel
        inputField.delegate = self
        inputField.target = self
        inputField.action = #selector(onEnterPressed)
        inputField.autoresizingMask = [.width, .maxYMargin]
        inputField.wantsLayer = true
        inputField.layer?.backgroundColor = NSColor(white: 1.0, alpha: 0.6).cgColor
        effectView.addSubview(inputField)
        
        let btnX: CGFloat = 640
        
        sendButton = NSButton(title: "Send", target: self, action: #selector(onSendClicked))
        sendButton.bezelStyle = .rounded
        sendButton.frame = NSRect(x: btnX, y: bottomY, width: 70, height: buttonHeight)
        sendButton.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(sendButton)
        
        let uploadBtn = NSButton(title: "Upload", target: self, action: #selector(onUploadClicked))
        uploadBtn.bezelStyle = .rounded
        uploadBtn.frame = NSRect(x: btnX + 80, y: bottomY, width: 70, height: buttonHeight)
        uploadBtn.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(uploadBtn)
        
        let clearBtn = NSButton(title: "Clear", target: self, action: #selector(onClearClicked))
        clearBtn.bezelStyle = .rounded
        clearBtn.frame = NSRect(x: btnX + 160, y: bottomY, width: 70, height: buttonHeight)
        clearBtn.autoresizingMask = [.minXMargin, .maxYMargin]
        effectView.addSubview(clearBtn)
    }
    
    // ==========================================
    // 逻辑处理
    // ==========================================
    
    @objc private func onEnterPressed() {
        onSendClicked()
    }
    
    @objc private func onSendClicked() {
        let input = inputField.stringValue
        guard !input.isEmpty else { return }
        
        if input == "/clear" {
            onClearClicked()
            inputField.stringValue = ""
            return
        }
        
        processUserMessage(input)
        inputField.stringValue = ""
    }
    
    @objc private func onUploadClicked() {
        let panel = NSOpenPanel()
        panel.canChooseFiles = true
        panel.allowsMultipleSelection = false
        panel.allowedContentTypes = [.plainText, .sourceCode, .json, .xml, .html]
        
        panel.beginSheetModal(for: self.window!) { response in
            if response == .OK, let url = panel.urls.first {
                DispatchQueue.global(qos: .userInitiated).async {
                    do {
                        let content = try String(contentsOf: url, encoding: .utf8)
                        let msg = "[File Upload: \(url.lastPathComponent)]\n\n\(content)"
                        DispatchQueue.main.async {
                            self.processUserMessage(msg)
                        }
                    } catch {
                        DispatchQueue.main.async {
                            self.appendLog(header: "[Error]", content: error.localizedDescription, color: AppConfig.Colors.error)
                        }
                    }
                }
            }
        }
    }
    
    @objc private func onClearClicked() {
        chatHistory.removeAll()
        saveHistoryInBackground() // [优化] 异步清空
        
        textContentStorage.performEditingTransaction {
            textContentStorage.textStorage?.deleteCharacters(in: NSRange(location: 0, length: textContentStorage.textStorage!.length))
        }
        appendLog(header: "[System]", content: "History cleared.", color: AppConfig.Colors.system)
    }
    
    private func processUserMessage(_ text: String) {
        appendLog(header: "You", content: text, color: AppConfig.Colors.user)
        
        let userMsg = ChatMessage(role: "user", parts: [ChatPart(text: text, thought: nil)])
        chatHistory.append(userMsg)
        
        // [优化] 不要在主线程保存
        saveHistoryInBackground()
        
        callGeminiAPI()
    }
    
    // ==========================================
    // API 网络请求
    // ==========================================
    
    private func callGeminiAPI() {
        setUIEnabled(false)
        
        Task {
            do {
                // [优化] 发送请求时只带上最近的 N 条记录，减少 token 消耗和上下文超长错误
                let contextHistory = Array(chatHistory.suffix(AppConfig.maxHistoryMessages))
                let response = try await fetchGeminiResponse(history: contextHistory)
                
                await MainActor.run {
                    self.handleAPIResponse(response)
                    self.setUIEnabled(true)
                }
            } catch {
                await MainActor.run {
                    self.appendLog(header: "[Network Error]", content: error.localizedDescription, color: AppConfig.Colors.error)
                    self.setUIEnabled(true)
                }
            }
        }
    }
    
    private func fetchGeminiResponse(history: [ChatMessage]) async throws -> APIResponse {
        guard let url = URL(string: AppConfig.modelEndpoint + AppConfig.apiKey) else {
            throw URLError(.badURL)
        }
        
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let payload = APIRequest(contents: history)
        request.httpBody = try JSONEncoder().encode(payload)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        return try JSONDecoder().decode(APIResponse.self, from: data)
    }
    
    private func handleAPIResponse(_ response: APIResponse) {
        if let error = response.error {
            appendLog(header: "[API Error]", content: error.message, color: AppConfig.Colors.error)
            return
        }
        
        guard let candidate = response.candidates?.first,
              let parts = candidate.content.parts, !parts.isEmpty else {
            return
        }
        
        var fullText = ""
        var fullThought = ""
        
        for part in parts {
            if let thought = part.thought {
                fullThought += thought + "\n"
            }
            if let text = part.text {
                fullText += text
            }
        }
        
        if !fullThought.isEmpty {
            appendLog(header: "Thinking", content: fullThought.trimmingCharacters(in: .whitespacesAndNewlines), color: AppConfig.Colors.thought)
        }
        
        if !fullText.isEmpty {
            appendLog(header: "Gemini", content: fullText, color: AppConfig.Colors.model)
            
            let modelMsg = ChatMessage(role: "model", parts: [ChatPart(text: fullText, thought: fullThought.isEmpty ? nil : fullThought)])
            chatHistory.append(modelMsg)
            saveHistoryInBackground() // [优化] 异步保存
        }
    }
    
    // ==========================================
    // 辅助方法：UI与存储
    // ==========================================
    
    private func appendLog(header: String, content: String, color: NSColor) {
        // [优化] 预先创建属性字典，减少 transaction 内部计算量
        let paraStyle = NSMutableParagraphStyle()
        paraStyle.lineBreakMode = .byWordWrapping
        paraStyle.lineHeightMultiple = AppConfig.Fonts.lineHeightMult
        
        let headerAttrs: [NSAttributedString.Key: Any] = [
            .font: AppConfig.Fonts.header,
            .foregroundColor: color,
            .paragraphStyle: paraStyle
        ]
        
        let contentAttrs: [NSAttributedString.Key: Any] = [
            .font: AppConfig.Fonts.text,
            .foregroundColor: color,
            .paragraphStyle: paraStyle
        ]
        
        let mas = NSMutableAttributedString()
        mas.append(NSAttributedString(string: "\(header)\n", attributes: headerAttrs))
        mas.append(NSAttributedString(string: "\(content)\n\n", attributes: contentAttrs)) // 合并空行
        
        textContentStorage.performEditingTransaction {
            textContentStorage.textStorage?.append(mas)
        }
        
        // [优化] 移除 ensureLayout(for: documentRange)
        // 那个调用会强制重新计算整个文档的布局，极其消耗 CPU。
        // 只需让 textView 滚动到可视区域，布局引擎会自动按需计算。
        scrollToBottom()
    }
    
    private func scrollToBottom() {
        DispatchQueue.main.async {
            self.textView.scrollToEndOfDocument(nil)
        }
    }
    
    private func setUIEnabled(_ enabled: Bool) {
        inputField.isEnabled = enabled
        sendButton.isEnabled = enabled
    }
    
    // ==========================================
    // [优化] 历史记录：异步 I/O
    // ==========================================
    
    private func loadHistoryFromDisk() {
        // 加载通常只需一次，且在启动时，允许在主线程或 userInitiated 队列
        let fileURL = URL(fileURLWithPath: AppConfig.historyFilePath)
        guard FileManager.default.fileExists(atPath: fileURL.path) else { return }
        
        DispatchQueue.global(qos: .userInitiated).async {
            do {
                let data = try Data(contentsOf: fileURL)
                let loadedHistory = try JSONDecoder().decode([ChatMessage].self, from: data)
                
                DispatchQueue.main.async {
                    self.chatHistory = loadedHistory
                    self.appendLog(header: "[System]", content: "Restored \(loadedHistory.count) messages", color: AppConfig.Colors.system)
                    
                    // 仅渲染最后几条，提升启动速度？(这里先保留渲染全部，但可优化)
                    for msg in loadedHistory {
                        let roleDisplay = msg.role == "user" ? "You" : "Gemini"
                        let color = msg.role == "user" ? AppConfig.Colors.user : AppConfig.Colors.model
                        let text = msg.parts.first?.text ?? ""
                        self.appendLog(header: roleDisplay, content: text, color: color)
                    }
                }
            } catch {
                print("Failed to load history: \(error)")
            }
        }
    }
    
    private func saveHistoryInBackground() {
        // [优化] 深拷贝数据以避免多线程访问冲突（Value Type 写时复制特性）
        let historyToSave = self.chatHistory
        
        ioQueue.async {
            // 只保存最近 N 条，防止文件无限大 (可选)
            // let subset = historyToSave.suffix(100)
            
            let fileURL = URL(fileURLWithPath: AppConfig.historyFilePath)
            do {
                let data = try JSONEncoder().encode(historyToSave)
                try data.write(to: fileURL, options: .atomic)
            } catch {
                print("Background save failed: \(error)")
            }
        }
    }
}

// ==========================================
// 4. App Entry
// ==========================================

class AppDelegate: NSObject, NSApplicationDelegate {
    var windowController: ChatWindowController!
    
    func applicationDidFinishLaunching(_ notification: Notification) {
        setupMainMenu()
        windowController = ChatWindowController()
        windowController.showWindow(self)
        NSApp.activate(ignoringOtherApps: true)
        windowController.window?.makeKeyAndOrderFront(nil)
        windowController.window?.toggleFullScreen(nil)
    }
    
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return true
    }
    
    private func setupMainMenu() {
        let mainMenu = NSMenu()
        NSApp.mainMenu = mainMenu
        
        let appMenuItem = NSMenuItem()
        mainMenu.addItem(appMenuItem)
        let appMenu = NSMenu()
        appMenuItem.submenu = appMenu
        appMenu.addItem(withTitle: "Quit Gemini", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        
        let editMenuItem = NSMenuItem()
        mainMenu.addItem(editMenuItem)
        let editMenu = NSMenu(title: "Edit")
        editMenuItem.submenu = editMenu
        editMenu.addItem(withTitle: "Cut", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        editMenu.addItem(withTitle: "Copy", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        editMenu.addItem(withTitle: "Paste", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        editMenu.addItem(withTitle: "Select All", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
    }
}

@main
struct GeminiApp {
    static func main() {
        if CommandLine.arguments.count > 1 {
            AppConfig.apiKey = CommandLine.arguments[1]
        }
        let app = NSApplication.shared
        app.setActivationPolicy(.regular)
        let delegate = AppDelegate()
        app.delegate = delegate
        app.run()
    }
}
