//swiftc -O -framework SwiftUI -framework AppKit Gemini.swift -o Gemini
import SwiftUI
import AppKit
import Observation

// MARK: - 1. 模型层 (保持不变，逻辑层对CPU影响极小)
@Observable
class ChatViewModel {
    var chatHistory: [ChatMessage] = []
    var isSending = false
    var apiKey: String = ""
    var isLowPowerMode: Bool = ProcessInfo.processInfo.isLowPowerModeEnabled
    
    init() {
        NotificationCenter.default.addObserver(
            forName: NSNotification.Name.NSProcessInfoPowerStateDidChange,
            object: nil,
            queue: .main
        ) { [weak self] _ in
            self?.isLowPowerMode = ProcessInfo.processInfo.isLowPowerModeEnabled
        }
    }

    func loadHistory() {
        let path = "/tmp/gemini_history_swift.json"
        guard let data = try? Data(contentsOf: URL(fileURLWithPath: path)),
              let decoded = try? JSONDecoder().decode([ChatMessage].self, from: data) else { return }
        self.chatHistory = decoded
    }
    
    func saveHistory() {
        let path = "/tmp/gemini_history_swift.json"
        if let data = try? JSONEncoder().encode(chatHistory) {
            try? data.write(to: URL(fileURLWithPath: path))
        }
    }
    
    func sendToGemini(text: String) async {
        guard !text.isEmpty else { return }
        await MainActor.run {
            chatHistory.append(ChatMessage(role: "user", parts: [ChatPart(text: text)]))
            isSending = true
        }
        
        // 注意：请确保使用有效的模型名称
        let endpoint = "https://generativelanguage.googleapis.com/v1beta/models/gemini-3-flash-preview:generateContent?key=\(apiKey)"
        guard let url = URL(string: endpoint) else { return }
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        request.httpBody = try? JSONEncoder().encode(["contents": chatHistory])
        
        do {
            let (data, _) = try await URLSession.shared.data(for: request)
            if let response = try? JSONDecoder().decode(GeminiResponse.self, from: data),
               let modelText = response.candidates.first?.content.parts.first?.text {
                await MainActor.run {
                    chatHistory.append(ChatMessage(role: "model", parts: [ChatPart(text: modelText)]))
                    saveHistory()
                }
            } else {
                if let errorStr = String(data: data, encoding: .utf8) { print("API Error: \(errorStr)") }
            }
        } catch { print("Network Error: \(error)") }
        await MainActor.run { isSending = false }
    }
}

struct ChatMessage: Codable, Identifiable, Equatable {
    var id = UUID(); let role: String; let parts: [ChatPart]
    enum CodingKeys: String, CodingKey { case role, parts }
    
    // Equatable 手动实现：让 View 知道如果 ID 没变，内容就没变
    static func == (lhs: ChatMessage, rhs: ChatMessage) -> Bool {
        return lhs.id == rhs.id && lhs.parts.first?.text == rhs.parts.first?.text
    }
}
struct ChatPart: Codable { let text: String }
struct GeminiResponse: Codable {
    struct Candidate: Codable {
        struct Content: Codable { let parts: [ChatPart] }; let content: Content
    }
    let candidates: [Candidate]
}

// MARK: - 2. UI 层 (深度优化)

// 优化 1: 提取单独的 Row View 并遵守 Equatable
// 这可以防止 ScrollView 在更新时重绘所有的 Text，只绘制新增的
struct MessageRow: View, Equatable {
    let msg: ChatMessage
    
    var body: some View {
        VStack(alignment: .leading, spacing: 6) {
            Text(msg.role == "user" ? "You" : "Gemini")
                .font(.system(size: 12, weight: .semibold))
                .foregroundColor(.secondary)
            
            Text(msg.parts.first?.text ?? "")
                .font(.system(size: 15)) // 稍微减小字号以提升渲染密度
                .lineSpacing(4)
                .fixedSize(horizontal: false, vertical: true) // 确切告诉布局引擎只需垂直扩展
                .foregroundColor(msg.role == "user" ? .primary : Color(nsColor: .darkGray))
                .textSelection(.enabled)
        }
        .padding(.vertical, 4)
    }
    
    static func == (lhs: MessageRow, rhs: MessageRow) -> Bool {
        return lhs.msg == rhs.msg
    }
}

struct ContentView: View {
    @Bindable var viewModel: ChatViewModel
    @State private var inputText = ""
    
    // 使用纯色代替材质，显著降低 CPU
    let paperColor = Color(red: 0.98, green: 0.976, blue: 0.965)
    let inputAreaColor = Color(red: 0.95, green: 0.95, blue: 0.95)

    var body: some View {
        VStack(spacing: 0) {
            ScrollViewReader { proxy in
                ScrollView {
                    // 保持 VStack 以解决按键滚动问题，但因为内部 View 是 Equatable，性能依然很高
                    VStack(alignment: .leading, spacing: 20) {
                        ForEach(viewModel.chatHistory) { msg in
                            MessageRow(msg: msg)
                                .id(msg.id)
                        }
                    }
                    .padding(24) // 减少 padding 复杂度
                }
                .focusable()
                .onChange(of: viewModel.chatHistory.count) {
                    if let lastId = viewModel.chatHistory.last?.id {
                        // 使用动画可能导致 CPU 峰值，immediate 滚动更省资源
                        proxy.scrollTo(lastId, anchor: .bottom)
                    }
                }
            }
            
            // 底部输入区
            HStack(spacing: 10) {
                TextField("Ask Gemini...", text: $inputText)
                    .textFieldStyle(.plain) // 自定义样式比 roundedBorder 更轻量
                    .padding(8)
                    .background(Color.white)
                    .cornerRadius(6)
                    .overlay(
                        RoundedRectangle(cornerRadius: 6)
                            .stroke(Color.gray.opacity(0.2), lineWidth: 1)
                    )
                    .onSubmit { sendMessage() }
                    .disabled(viewModel.isSending)
                
                Button(action: sendMessage) {
                    if viewModel.isSending {
                        ProgressView().controlSize(.small).scaleEffect(0.8)
                    } else {
                        Text("Send").fontWeight(.medium)
                    }
                }
                .buttonStyle(.bordered) // Prominent 样式有时候绘制开销稍大
            }
            .padding(12)
            // 优化 2: 移除 Material，使用实色背景
            // .ultraThinMaterial 会导致 Window Server 持续进行背景模糊运算
            .background(inputAreaColor)
            .overlay(alignment: .top) {
                Divider() // 简单的分割线代替复杂的阴影
            }
        }
        .background(paperColor) 
    }
    
    func sendMessage() {
        let text = inputText; guard !text.isEmpty else { return }; inputText = ""
        Task { await viewModel.sendToGemini(text: text) }
    }
}

// MARK: - 3. 应用入口 (保持不变)
class AppDelegate: NSObject, NSApplicationDelegate {
    var window: NSWindow!
    var viewModel = ChatViewModel()

    func applicationDidFinishLaunching(_ notification: Notification) {
        setupMenu()
        if CommandLine.arguments.count > 1 { viewModel.apiKey = CommandLine.arguments[1] }
        viewModel.loadHistory()

        window = NSWindow(
            contentRect: NSRect(x: 0, y: 0, width: 700, height: 550), // 稍微调小默认窗口
            styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
            backing: .buffered, defer: false)
        window.center()
        window.title = "Gemini Reader"
        // 移除全透明相关设置，提升渲染性能
        window.isOpaque = true 
        window.titlebarAppearsTransparent = true
        
        window.contentView = NSHostingView(rootView: ContentView(viewModel: viewModel))
        window.makeKeyAndOrderFront(nil)
        NSApp.activate(ignoringOtherApps: true)
    }
    
    func setupMenu() {
        let mainMenu = NSMenu()
        let appMenuItem = NSMenuItem()
        mainMenu.addItem(appMenuItem)
        let appMenu = NSMenu()
        appMenuItem.submenu = appMenu
        appMenu.addItem(withTitle: "Quit", action: #selector(NSApplication.terminate(_:)), keyEquivalent: "q")
        
        let editMenuItem = NSMenuItem()
        mainMenu.addItem(editMenuItem)
        let editMenu = NSMenu(title: "Edit")
        editMenuItem.submenu = editMenu
        editMenu.addItem(withTitle: "Cut", action: #selector(NSText.cut(_:)), keyEquivalent: "x")
        editMenu.addItem(withTitle: "Copy", action: #selector(NSText.copy(_:)), keyEquivalent: "c")
        editMenu.addItem(withTitle: "Paste", action: #selector(NSText.paste(_:)), keyEquivalent: "v")
        editMenu.addItem(withTitle: "Select All", action: #selector(NSText.selectAll(_:)), keyEquivalent: "a")
        
        NSApp.mainMenu = mainMenu
    }
    
    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool { return true }
}

let app = NSApplication.shared
let delegate = AppDelegate()
app.delegate = delegate
app.setActivationPolicy(.regular)
app.run()
